# 一、基本介绍

单线程模型，基于c语言实现的内存数据库，处理高性能和高并发问题的缓存数据库

- 高性能：用户读取数据时从redis中读比从数据库中读取更快，性能更高
  - redis将数据存在内存中，内存中数据的访问速度比从磁盘上访问数据快上千倍
  - redis有更好的，优化的数据机构
  - redis基于Reactor模式设计了自己的网络事件处理器，主要是单线程事件循环和IO多路复用
- 高并发：redis的qbs（每秒钟访问的次数）是10w+（单机模式，集群下更高），mysql的qbs是1w（4核8g）

## 二、底层数据结构

### （1）SDS（动态字符串）

主要用于实现String

SDS有五种实现方式

| 类型     | 字节 | 位   |
| -------- | ---- | ---- |
| sdshdr5  | <1   | <8   |
| sdshdr8  | 1    | 8    |
| sdshdr16 | 2    | 16   |
| sdshdr32 | 4    | 32   |
| sdshdr34 | 8    | 64   |



第一种很少使用，主要使用后四种，他们都包含下列属性

- len：字符串的长度（已经使用的字节数）
  - 可以避免缓冲区溢出：SDS进行修改时先修改len来请求空间大小是否满足要求，如果不满足则先扩展
  - 获取字符串长度复杂度变低：SDS直接读取len就可以获得长度，不需要像c语言一样遍历
  - 二进制安全：c语言以字符\0作为字符串结束符，一些二进制文件（图片，视频，音频等）就可能包含空字符，但是有了len的话就是通过len来判断结束，不存在这个问题
- alloc：总共可用的字符空间的大小，alloc-len就是SDS剩余的空间大小
- buf[]：实际存储字符串的数组
- flags：低三维保存类型标志

SDS相比较于c语言的String，可以减少内存分配次数：为了避免修改字符串时需要重新分配内存，SDS实现了空间预分配和惰性空间释放两种优化策略。

- 当SDS需要增加字符串时Redis会为SDS分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重新分配次数
- 当SDS需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后序使用（也有api支持手动释放）

> 这样也会造成内存碎片：（1）redis存储数据的时候会向操作系统申请更多的内存空间（2）频繁修改redis中的数据（数据删除时redis不会轻易释放内存给操作系统）
>
> 内存碎片也就是不可用的空闲内存，内存碎片不会影响redis的性能，只是会占用内存空间
>
> 解决：（1）通过自身的内存整理（可能对redis性能产生影响）（2）重启对应节点的redis

### （2）LinkedList（双向链表）

### （3）SkipList（跳跃表）

### （4）ZipList（压缩列表）

### （5）QuickList（快速列表）

### （6）Dict（哈希表/字典）

### （7）Intset（整数集合）

### （8）bitmap

## 三、五种基本数据机构

### 1.String

#### （1）实现：SDS

#### （2）介绍：二进制安全的数据机构，用于存储任何类型的数据（字符串，整数，浮点数，图片url或者编码，序列化后的对象）

#### （3）相关命令

key可以看做是对象的名字，value是具体的值

| 命令                             | 作用                           |
| -------------------------------- | ------------------------------ |
| set key value                    | 指定key的值                    |
| get key                          | 获取ket                        |
| mset key1 value1，key2 value2... | 指定多个key的值                |
| mget key1，key2....              | 获取多个key的值                |
| setnx key value                  | 只有key不存在的时候指定key的值 |
| incr key                         | 将key存储的数字值+1            |
| decr key                         | 将key存储的数字值-1            |
| exists key                       | 判断key是否存在                |
| del key（通用）                  | 删除key                        |
| expire key time（通用）          | 给key设置过期时间              |



#### （4）场景

- 存储session，token，图片地址，序列化后的对象
- 用户单位时间的请求数（限流），页面单位时间的访问数
- 分布式锁：通过setnx命令简单实现（存在缺陷）

> 限流：将数字类型的数据存入进去，通过incr进行增加，达到一定量的时候进行具体操作即可

> 为什么要使用分布式锁：像解决秒杀活动，超卖问题一样，我们一般用悲观锁来解决这种多线程之间的问题，但是当部署了分布式的项目，那么就变成了进程之间进行操作，本地锁没办法实现互斥，要对每一个JVM进程进行加锁就是使用了分布式锁

分布式锁产生条件：

- 互斥：任何一个时刻锁只能被一个线程持有
- 高可用：锁的服务是高可用的，当一个锁服务出现问题，能够自动切换到另一个锁服务，即使客户端的释放锁代码出现问题还是会释放锁（超时机制），不会影响其他线程的访问
- 可重入：一个节点获取锁之后还可以再次获取锁
- 高性能（非必须）：获取锁和释放锁的操作应该快速完成，并且不应该对操作系统造成过大的影响
- 非阻塞（非必须）：如果获取不到锁，不能无期限等待避免对系统正常运行造成阻塞

使用setnx实现场景：

- 获取锁：setnx命令可以帮我们实现互斥，获取锁就直接通过setnx进行加锁，只有当锁没存在时才能加锁，如果已经存在那么在调用这个命令无效（返回另外的值），这样就实现了互斥
- 释放锁：del这个命令删除对应的key即可，为了防止互删使用Lua脚本来对锁的唯一值进行判断（Lua脚本能一定程度确保锁的原子性），同时要给锁设定一个过期时间`set 加锁的锁名 能够唯一标识锁的随机字符串 EX 3(3秒) NX(只有当锁对应的key值不存在的时候才能set成功) `，避免客户端挂掉造成未释放锁的操作，**同时还要保证设置指定key的值和过期时间是一个原子操作**
- 问题：如果操作共享资源的时间大于过期时间，就会导致锁提前过期进而导致分布式锁直接失效，设置过长又会影响性能，所以自己进行续期，通过Redisson里面的watch dog 来实现锁的续期，也可以通过Redisson来实现可重入锁（一个线程可以多次获取同一把锁，synchronized和ReentrantLock都属于可重入锁）

### 2.Hash

#### （1）实现：Dict、zipList

#### （2）介绍：像hashmap一样存储类似String类型的键值对，常用于存储很多个字段值的对象

#### （3）命令

key表示对象，field是字段名，value是字段值

| 命令                                       | 作用                             |
| ------------------------------------------ | -------------------------------- |
| hset key filed value                       | 指定哈希表中指定字段的值         |
| hget key filed                             | 获取指定哈希表指定字段的值       |
| hmset key filed1 value1，filed2 value2 ... | 指定多个字段的值                 |
| hmget key filed1，filed2...                | 获取多个字段的值                 |
| hmsetnx key filed value                    | 指定字段不存在时设置指定字段的值 |
| hgetall key                                | 获取指定哈希表的所有字段         |
| hexists key filed                          | 判断指定字段是否存在             |
| hdel key filed1，filed2..                  | 删除指定字段                     |
| hlen key                                   | 获取哈希表中的字段数量           |
| hincrby key filed increment                | 对指定字段进行运算操作（正+负-） |

#### （4）场景：存储用户信息，购物车信息，文章信息，商品信息等

### 3.List

#### （1）实现：LinkedList/ZipList/QuickList

Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代

#### （2）介绍：视为list实现的双向链表

#### （3）命令

| 命令                     | 作用                         |
| ------------------------ | ---------------------------- |
| rpush key value1,value2  | 在列表尾部开始插入元素       |
| lpush key value1，value2 | 在列表头部开始插入元素       |
| lset key index value     | 指定列表索引的index处的值    |
| lpop key                 | 移除最左边元素并返回         |
| rpop key                 | 移除最右边元素并返回         |
| llen key                 | 获取列表元素的数量           |
| lrange key start end     | 获取列表start和end之间的元素 |



可以实现队列或者栈

#### （4）场景

- 最新文章、最新动态
- 消息队列

redis实现消息队列的三种方式

- list集合：通过rpush/lpop或者lpush/rpop’的方式实现简易的消息队列
  - 缺陷：性能低，不断轮询集合，没有确认消息机制，也没有广播机制，消息还只能被消费一次
- 发布订阅功能：pub/sub引入的Channel（频道），解决了广播的问题
  - 发布者通过publish投递消息给指定的channel
  - 消费者通过subscribe订阅对应的频道
- Redis5.0新增的Stream数据机构来做消息队列，Stream支持（存在消息丢失和堆积的问题）
  - 发布/订阅模式
  - 按照消费组进行消费
  - 消息持久化（RDB和AOF）

### 4.Set

#### （1）实现：Dict，Intset

#### （2）介绍：不重复的集合，存储不重复的元素，常用于并集，交集，差集

#### （3）命令

| 命令                          | 作用                                   |
| ----------------------------- | -------------------------------------- |
| sadd key member1 member2      | 向指定集合添加一个或多个元素           |
| smembers key                  | 获取指定集合中的所有元素               |
| scard key                     | 获取指定集合的元素数量                 |
| sismembers key member         | 判断该集合是否存在该元素               |
| sinter key1 key2...           | 获取给定集合的交集（返回元素）         |
| sinterstore key3 key1 key2..  | 将获取的交集存储在key3中               |
| sunion key1 key2...           | 获取给定集合的并集（返回元素）         |
| sunionstore key3 key1，key2.. | 将获取的并集存储在key3中               |
| sdiff key1 key2....           | 获取给定集合的差集（返回元素）         |
| sdiffstore key3 key1 key2..   | 将获取的差集存储在key3中               |
| spop key count                | 随机移除并获取指定集合中一个或多个元素 |
| srandmember key count         | 随机获取指定集合中指定数量的元素       |



#### （4）场景

- 存放的数据不能重复的场景：网站UV统计（数据量大还是用HyperLogLog），文章点赞，动态点赞等（scrad）
- 需要获取差集，交集，并集的场景：共同好友，共同粉丝，共同关注，好友推荐等

### 5.ZSet（Sorted Set）

#### （1）实现：ZipList，SkipList

#### （2）介绍：相比较于set每个值多了个权重参数score，让他们变得有序

#### （3）命令

| 命令                                      | 作用                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| zadd key member1 score1  member2 score2.. | 向指定有序集合添加一个或多个元素                             |
| zcard key                                 | 获取指定有序集合的元素数量                                   |
| zscore key member                         | 获取指定有序集合指定元素的score                              |
| zinterstore key3 numkeys key1 key2...     | 将给定有序集合的交集存储在key3中，对相应元素对应的score进行sum操作，numkeys为集合数量 |
| zunionstore key3 numkeys key1 key2..      | 求并集                                                       |
| zdiffstore key3 numkeys key1 key2...      | 求差集                                                       |
| zrange key start end                      | 获取有序集合start和end之间的元素（从低到高）                 |
| zrevrange key start end                   | 获取有序集合start和end之间的元素（从高到低）                 |
| zrevrank key member                       | 获取指定有序集合中指定元素的排名（score从大到小排序）        |



#### （4）场景：礼物排行榜，步数排行榜，热度排行榜等

## 四、三种特殊数据结构

## 五、持久化

## 六、线程模型

## 七、内存管理

## 八、阻塞原因