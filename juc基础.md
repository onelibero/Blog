# 一、进程和线程（JVM层面）

## 1.从JVM层面介绍进程和线程

### （1）进程

在java中，启动一个main函数时就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，叫做主线程

### （2）线程

线程是比进程更小的执行单位，一个进程在其执行过程中可以产生多个线程，线程也被称为轻量级进程

### （3）关系

![运行时时区.png](/upload/运行时时区.png)

#### a.程序计数器

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 在多线程情况下，程序计数器会记录当前线程执行位置，当该线程被切换回来时能知道上次运行到哪里了（程序计数器私有主要就是为了线程切换后能回复到当前位置）

#### [b.java](http://b.java)虚拟机栈

java虚拟机栈的生命周期和线程相同。方法调用的数据通过栈进行传递，他是由一个个栈帧组成，

栈帧组成：

1. 局部变量表：主要存放编译器的各种数据类型和对象引用
2. 操作数栈：主要作为方法调用的中间站，存放方法执行过程中产生的中间计算结果
3. 动态链接：主要服务一个方法需要调用其他方法的场景。class文件的常量池中保存大量的符号引用，当一个方法要调用其他方法的时候，需要将常量池中指向方法的符号转化为其在内存地址上的直接引用，动态链接的作用就是完成这个转化过程

可能存在错误：

- SatckOverFlowError：如果栈不是动态扩展时，当线程请求栈的深度超过了java虚拟机栈的最大深度，就会报错
- OutOfMemoryError：如果栈是动态扩展的，当虚拟机动态扩展时申请不到足够的内存空间就是报错

#### c.本地方法栈

与java虚拟机栈类似，只是java虚拟机栈是针对java方法，本地方法栈是针对native方法

#### d.堆

java虚拟机所管理的最大的一块内存，主要是用于垃圾回收的区域，所以也叫GC堆，此区域几乎存放了所有的实例对象，几乎所有的实例对象都是在这里分配内存（为什么是几乎，是因为JIT编译器的逃逸分析，也就是如果某些方法中的对象引用没有被返回或者未被外面使用，那么就会在自己的栈上分配内存）

堆内存分为三部分：

- 新生代内存：
  - Eden：大部分情况对象都会在此处分配内存
  - s0：一次新生代垃圾回收后，如果对象存活，并且对象年龄+1
  - s1：一次新生代垃圾回收后，如果对象存活，并且对象年龄+1
- 老年代：当年龄增长到一定程度（默认15）
- 永久的（jdk8之后改为了元空间，元空间使用的是本地内存）

> 为什么改成元空间
>
> - 永久代有jvm本身设置的固定大小，无法调整，元空间使用的是本地内存，受本地内存限制但是溢出比原来出现的几率更小
> - 元空间存放的是类的元数据，这样加载多少类的元数据就由操作的实际可用空间来控制，这样能加载的类就更多了
> - 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了

常见错误：

- `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误

#### e.方法区

是jvm运行时数据区域一块逻辑区域

当虚拟机使用一个类时，会读取并解析class文件获取相关信息，在将信息存入到方法区。方法区会存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、代码缓存**等数据

方法区相当于是接口，永久代和元空间来进行实现

## 2.基本概念

### （1）并发和并行

- 并发：两个及两个以上的作业在同一时间段内执行
- 并行：两个及两个以上的作业在同一时刻执行

### （2）同步和异步

- 同步：发出一个调用之后，在没有得到结果之前，该调用不可以返回要一直等待
- 异步：调用在发出之后，不用等待返回结果，该调用可以直接返回

### （3）为什么使用多线程

- 从计算机：线程切换和调度的成本小于进程，多核CPU时代意味着多个线程可以同时运行，减少了线程上下文切换的开销
  - 单核：假如有一个线程请求IO，此时如果是多线程，那么就可以在进行IO阻塞的时候运行其他线程，提高了系统的利用率
  - 多核：提高了进程利用多核CPU的能力
- 从发展趋势：现在的数据量大大增多，多线程是高并发的基础

### （4）多线程产生的问题

- 内存泄露
- 死锁
- 线程不安全

### （5）线程安全和不安全

- 线程安全：在多线程环境下，对于同一份数据，无论有多少个线程进行访问，都能保证当前线程的正确性和一致性
- 线程不安全：在多线程环境下，对于同一份数据，当多个线程同时访问时可能会导致数据错乱、错误或丢失

### （6）线程的生命周期和状态

1. 新建状态（刚new出线程）
2. 就绪状态（start启动线程）
3. 运行状态
4. 阻塞状态（sleep）：让当前线程暂停执行,主要用作线程间通信/交互
5. 等待状态（wait）：线程需要其他线程调用notify或者notifyall来唤醒
   1. 超时等待状态（wait设置了时间）：线程会在这个时间之后自动唤醒
6. 终止状态

#### sleep()方法和wait()方法

- sleep方法没有释放锁，wait方法释放了锁
- sleep主要暂停线程执行，wait主要用于线程间通信/交互
- sleep属于thread，wait属于object
  - 因为sleep的目的是暂停当前线程，不涉及类，所以存在thread中
  - 因为wait主要是让获得对象锁的线程实现等待，会自动释放当前线程占用的对象锁，而每个对象都拥有对象锁，所以wait主要是操作对象，所以存在于object
- sleep自动醒，wait如果不是超时等待需要其他线程唤醒

### （7）线程上下文切换

上下文：线程在执行过程中自己的运行条件和状态

上下文切换：保留当前线程的上下文，加载下一个将要占用CPU的线程的上下文，这个就叫线程上下文切换

出现线程上下文切换情况：

1. 主动让出CPU，如调用了sleep或者wait方法
2. 时间片用完
3. 调用了阻塞类型的系统中断，如请求IO

### （8）线程死锁

产生条件：

1. 互斥：一个资源只能被一个线程持有
2. 请求与保持：一个线程在获取新的资源之前，不会释放已有的资源
3. 不剥夺条件：线程已经获得的资源不会被其他线程强行获取，只能由该线程自动释放
4. 循环等待条件：若干线程直接形成一种头尾相连的资源等待关系

预防死锁：

1. 破坏请求与保持条件：一次性申请所有资源
2. 破坏不剥夺条件：线程在获取的资源获取不到时，释放自己占用的资源
3. 破坏循环等待条件：靠按序申请来获取资源、

避免死锁：银行家算法对资源分配进行评估

# 二、JMM

java内存模型，主要定义了一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性

## 1.CPU缓存模型

## 2.指令重排序

# 三、锁

# 四、ThreadLocal

# 五、线程池

# 六、AQS