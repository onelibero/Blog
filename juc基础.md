# 一、进程和线程（JVM层面）

## 1.从JVM层面介绍进程和线程

### （1）进程

在java中，启动一个main函数时就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，叫做主线程

### （2）线程

线程是比进程更小的执行单位，一个进程在其执行过程中可以产生多个线程，线程也被称为轻量级进程

### （3）关系

![运行时时区.png](/upload/运行时时区.png)

#### a.程序计数器

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 在多线程情况下，程序计数器会记录当前线程执行位置，当该线程被切换回来时能知道上次运行到哪里了（程序计数器私有主要就是为了线程切换后能回复到当前位置）

#### [b.java](http://b.java)虚拟机栈

java虚拟机栈的生命周期和线程相同。方法调用的数据通过栈进行传递，他是由一个个栈帧组成，

栈帧组成：

1. 局部变量表：主要存放编译器的各种数据类型和对象引用
2. 操作数栈：主要作为方法调用的中间站，存放方法执行过程中产生的中间计算结果
3. 动态链接：主要服务一个方法需要调用其他方法的场景。class文件的常量池中保存大量的符号引用，当一个方法要调用其他方法的时候，需要将常量池中指向方法的符号转化为其在内存地址上的直接引用，动态链接的作用就是完成这个转化过程

可能存在错误：

- SatckOverFlowError：如果栈不是动态扩展时，当线程请求栈的深度超过了java虚拟机栈的最大深度，就会报错
- OutOfMemoryError：如果栈是动态扩展的，当虚拟机动态扩展时申请不到足够的内存空间就是报错

#### c.本地方法栈

与java虚拟机栈类似，只是java虚拟机栈是针对java方法，本地方法栈是针对native方法

#### d.堆

java虚拟机所管理的最大的一块内存，主要是用于垃圾回收的区域，所以也叫GC堆，此区域几乎存放了所有的实例对象，几乎所有的实例对象都是在这里分配内存（为什么是几乎，是因为JIT编译器的逃逸分析，也就是如果某些方法中的对象引用没有被返回或者未被外面使用，那么就会在自己的栈上分配内存）

堆内存分为三部分：

- 新生代内存：
  - Eden：大部分情况对象都会在此处分配内存
  - s0：一次新生代垃圾回收后，如果对象存活，并且对象年龄+1
  - s1：一次新生代垃圾回收后，如果对象存活，并且对象年龄+1
- 老年代：当年龄增长到一定程度（默认15）
- 永久的（jdk8之后改为了元空间，元空间使用的是本地内存）

> 为什么改成元空间
>
> - 永久代有jvm本身设置的固定大小，无法调整，元空间使用的是本地内存，受本地内存限制但是溢出比原来出现的几率更小
> - 元空间存放的是类的元数据，这样加载多少类的元数据就由操作的实际可用空间来控制，这样能加载的类就更多了
> - 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了

常见错误：

- `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误

#### e.方法区

是jvm运行时数据区域一块逻辑区域

当虚拟机使用一个类时，会读取并解析class文件获取相关信息，在将信息存入到方法区。方法区会存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、代码缓存**等数据

方法区相当于是接口，永久代和元空间来进行实现

## 2.基本概念

### （1）并发和并行

- 并发：两个及两个以上的作业在同一时间段内执行
- 并行：两个及两个以上的作业在同一时刻执行

### （2）同步和异步

- 同步：发出一个调用之后，在没有得到结果之前，该调用不可以返回要一直等待
- 异步：调用在发出之后，不用等待返回结果，该调用可以直接返回

### （3）为什么使用多线程

- 从计算机：线程切换和调度的成本小于进程，多核CPU时代意味着多个线程可以同时运行，减少了线程上下文切换的开销
  - 单核：假如有一个线程请求IO，此时如果是多线程，那么就可以在进行IO阻塞的时候运行其他线程，提高了系统的利用率
  - 多核：提高了进程利用多核CPU的能力
- 从发展趋势：现在的数据量大大增多，多线程是高并发的基础

### （4）多线程产生的问题

- 内存泄露
- 死锁
- 线程不安全

### （5）线程安全和不安全

- 线程安全：在多线程环境下，对于同一份数据，无论有多少个线程进行访问，都能保证当前线程的正确性和一致性
- 线程不安全：在多线程环境下，对于同一份数据，当多个线程同时访问时可能会导致数据错乱、错误或丢失

### （6）线程的生命周期和状态

1. 新建状态（刚new出线程）
2. 就绪状态（start启动线程）
3. 运行状态
4. 阻塞状态（sleep）：让当前线程暂停执行,主要用作线程间通信/交互
5. 等待状态（wait）：线程需要其他线程调用notify或者notifyall来唤醒
   1. 超时等待状态（wait设置了时间）：线程会在这个时间之后自动唤醒
6. 终止状态

#### sleep()方法和wait()方法

- sleep方法没有释放锁，wait方法释放了锁
- sleep主要暂停线程执行，wait主要用于线程间通信/交互
- sleep属于thread，wait属于object
  - 因为sleep的目的是暂停当前线程，不涉及类，所以存在thread中
  - 因为wait主要是让获得对象锁的线程实现等待，会自动释放当前线程占用的对象锁，而每个对象都拥有对象锁，所以wait主要是操作对象，所以存在于object
- sleep自动醒，wait如果不是超时等待需要其他线程唤醒

### （7）线程上下文切换

上下文：线程在执行过程中自己的运行条件和状态

上下文切换：保留当前线程的上下文，加载下一个将要占用CPU的线程的上下文，这个就叫线程上下文切换

出现线程上下文切换情况：

1. 主动让出CPU，如调用了sleep或者wait方法
2. 时间片用完
3. 调用了阻塞类型的系统中断，如请求IO

### （8）线程死锁

产生条件：

1. 互斥：一个资源只能被一个线程持有
2. 请求与保持：一个线程在获取新的资源之前，不会释放已有的资源
3. 不剥夺条件：线程已经获得的资源不会被其他线程强行获取，只能由该线程自动释放
4. 循环等待条件：若干线程直接形成一种头尾相连的资源等待关系

预防死锁：

1. 破坏请求与保持条件：一次性申请所有资源
2. 破坏不剥夺条件：线程在获取的资源获取不到时，释放自己占用的资源
3. 破坏循环等待条件：靠按序申请来获取资源、

避免死锁：银行家算法对资源分配进行评估

# 二、JMM

java内存模型，主要定义了一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性

## 1.CPU缓存模型

> 为什么要弄一个CPU缓存模型？
>
> 好比我们引入redis来解决程序处理速度和访问常规关系型数据库速度不对等的问题一样的，CPU缓存是为了解决CPU处理速度和内存处理速度不对等的问题

CPU Cache缓存的是内存数据用于解决CPU处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题

### CPU Cache工作方式

先复制一份数据到Cpu Cache中，当CPU需要用到的时候可以直接从CPU Cache中读取数据，当运算完成后再将运算得到的数据写到Main Memory中，但是这样存在内存缓存不一致性的问题

> CPU解决内存缓存不一致性的问题可以通过指定缓存一致协议（如MESI协议），这个缓存一致协议指的是CPU告诉缓存与主内存交互的时候需要遵守的原则和规范，不同的CPU中使用的缓存一致性协议通常也会不同

操作系统通过**内存模型**来解决内存缓存不一致性问题（我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化）

## 2.指令重排序

指令重排序简单来说就是系统在执行代码的时候不一定是按照写的代码顺序来执行的，常见两种情况

- 编译器优化重排：编译器（JVM，JIT编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序
  - 处理：通过禁止特定类型的编译器重排序的方式来禁止重排序
- 指令并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行
  - 处理：插入内存屏障（一种CPU指令，用来禁止处理器发生重排序）

另外还可能存在内存系统重排（在JMM里表现为主存和本地内存的内容可能不一致，导致程序在多线程执行可能出现问题）

## JMM内存模型介绍

什么是JMM

- 为什么存在？java语言是跨平台的，不同操作系统的内存模型不同，如果直接复用操作系统层面的内存模型可能导致代码无法运行，所以java需要自己提供一套内存模型来屏蔽操作系统差异
- 对于java，可以吧JMM看做java定义的并发编程相关的一组规范（如volatile、synchronized、lock等）
  - 抽象了线程和主内存之间的关系
  - 规定了java源代码到CPU可执行指令的这个转化过程要遵守那些和并发相关的原则和规范
  - 目的：简化多线程编程，增强程序可移植性的

### JMM如何抽象化线程和主内存之间的关系

java的内存模型实现从主存中读取变量，而在当前java内存模型中线程可以吧变量保存本地内存，而不是直接在主内中进行读写。这样就可能导致一个线程在主存中修改了一个变量的值，而另外一个线程还在继续使用它在寄存器中的变量值的拷贝，造成数据不一致

**主内存**：所有线程创建的实例对象都存放在主内存中，不管该实例对象是否是成员变量还是方法中的本地变量（局部变量）

**本地内存**：每个线程私有的本地内存来存储共享变量的副本，并且每个线程只能访问自己的本地内存

基本操作：

- **锁定（lock）**: 作用于主内存中的变量，将他标记为一个线程独享变量。
- **解锁（unlock）**: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。
- **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
- **load(载入)**：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。
- **use(使用)**：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。
- **write（写入）**：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：

- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。

# 三、锁

# 四、ThreadLocal

# 五、线程池

## 介绍

线程池：管理一系列线程的资源池，每个线程池维护一些基本统计信息，列如已完成任务的数量

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗
- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控

## 实现

#### （1）通过ThreadPoolExector构造函数来创建

#### （2）通过Exector框架的工具类Exectors来创建

## Executor框架

`Executor` 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，`Executor` 框架让并发编程变得更加简单。（通过Exector启动线程比start方法更好）

## ThreadPoolExecutor类

提供了四个构造方法

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

- `keepAliveTime`:线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。
- `unit` : `keepAliveTime` 参数的时间单位。
- `threadFactory` :executor 创建新线程的时候会用到。
- `handler` :饱和策略。关于饱和策略下面单独介绍一下



# 六、AQS