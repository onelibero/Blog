# 一、java内存结构

![运行时时区.png](/upload/运行时时区.png)已知java运行时数据区是这样的，这整个部分是在直接内存中（电脑系统内存），还有两个组件`JVM字节码执行引擎`，`垃圾回收器`

都是针对整个JVM

## 直接内存

- 物理机的内存，不属于JVM内存结构，但是JVM虚拟机可以调用该部分内存
- 常见于NIO（New Input/Output），用于数据缓冲区
- 分配回收代价高，但是速度快
- 不受JVM内存回收管理

区别：直接内存申请空间耗费很高的性能，堆内存申请空间耗费较低，直接内存的IO读写的性能优于堆内存

## JVM字节码执行引擎

由于字节码不能直接运行在操作系统之上（字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表、以及其他信息），在JVM将字节码加载到其内部之后，JVM的执行引擎就会将其编译成对应平台的本地机器指令

## 垃圾收集系统

程序在运行过程中会产生大量的内存垃圾（一些没有引用指向的内存对象都属于内存垃圾，因为这些对象已经无法访问，对程序而言已经死亡），为了确保程序运行时的性能java虚拟机在程序运行过程中不断的进行自动的垃圾回收（GC）

# 二、JVM的垃圾回收机制

> 垃圾回收机制简称GC，主要用于java堆的管理，java中的堆是JVM管理的最大的一块内存空间，主要用于存放各种类的实例对象

在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。对于GC而言，在创建对象时，GC就开始监控这个对象的地址、大小及其使用情况

手动执行`GC System.gc();`

## java中的引用类型

1. 强引用：发生gc时不会被回收
2. 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收
3. 弱引用：有用但不是必须的对象，在下次GC时会被回收
4. 虚引用：用PhantomReference 实现虚引用，在gc时返回一个按钮

## 如何判断是否回收，什么时候回收

### 1.引用计数器法

为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数器-1，当计数器为0时就可以被回收。但是他有一个缺点是不能解决循环引用的问题

### 2.可达性分析算法

从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链时，证明此对象是可以被回收的

## JVM的垃圾回收算法

### 1.标记-清除算法

缺点：效率不高，无法清除垃圾碎片

标记无用对象，然后进行清除回收。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间，该算法缺陷在于内存碎片严重化，后续可能发生对象找不到利用空间的问题

### 2.复制算法

缺点：内存使用率不高，只有原来一半

按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后把已使用的内存空间一次清理

### 3.标记-整理算法

标记无用对象，让所存活的对象都向一端移动，然后直接清楚掉端边界以外的内存

标记后不是清除对象，是将存活的对象移向内存的一端，然后清除端边界以外的对象

### 4.分代算法

根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代（还有永久代），新生代基本采用复制算法，老年代采用标记-整理算法

> 新生代采用复制算法是因为每次垃圾收集时都会有大量对象死去，只有少量对象存活，采用复制算法只需要付出少量存活对象的复制成本就可以完成收集，老年代因为对象存活率高，没有额外的空间进行分配担保，就必须采用“标记-清理”或者“标记-整理”



# 三、垃圾收集器

java堆内存被划分为新年代和老年代两部分，新生代主要使用复制和标记-清除垃圾回收算法，老年代主要是标记-整理算法，所以java虚拟机针对他们提供了多种不同的垃圾收集器

### 新生代

- Serial收集器（复制算法）：新生代单线程收集器，标记和清除都是单线程，优点是简单高效
- ParNew收集器（复制算法）：相当于Serial的多线程版本，在多核cpu下比Serial更好
- Parallel Scavenge收集器（复制算法）：追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景

### 老年代

- Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本
- Parallel Old收集器 (标记-整理算法)： 吞吐量优先，Parallel Scavenge收集器的老年代版本
- CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间

### 整堆收集器（适用于新生代和老年代）：G1

1. 能充分利用多CPU、多核环境下的硬件优势；
2. 可以并行来缩短(Stop The World)停顿时间；
3. 也可以并发让垃圾收集与用户程序同时进行；
4. 分代收集，收集范围包括新生代和老年代
5. 能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；
6. 能够采用不同方式处理不同时期的对象；
7. 应用场景可以面向服务端应用，针对具有大内存、多处理器的机器；
8. 采用标记-整理 + 复制算法来回收垃圾



其余文章：

[初始JVM](https://onelibero.love/archives/jvm0)

[JVM运行时数据区域](https://oneliber.love/archives/jvm1)

[JVM各类加载机制](https://onelibero.love/archives/jvm2)