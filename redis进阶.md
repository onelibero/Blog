# 一、事务

Redis提供了**一种将多个命令请求打包的功能，然后按顺序执行打包的所有命令，并且不会被中途打断，**注意区别其与关系型数据库如mysql事务的区别

## 1.使用

- `MULTI:开启事务`：这个命令之后可以输入多个命令，Redis不会立即执行这些命令，而是会放到队列中
- `EXEC:提交事务`：调用EXEC命令后，会执行MULTI后输入的所有命令（FIFO顺序，即先进先出）
- `WATCH:监听key`：当watch命令监视了一个key，如果有其他客户端/session修改这个key，事务不会执行
- `DISCARD:取消事务`:会清空事务队列中保存的所有队列

## 2.Redis的事务特性

### （1）不支持原子性

Redis事务在运行错的情况下，除了出现错误指令的命令外，其余指令都会正常执行，并且Redis不支持回滚（mysql里面有undo log日志所以支持回滚），所以Redis不支持原子性

#### 解决其缺陷

Redis在2.6版本之后开始使用Lua脚本，与事务非常类似，Lua脚本可以批量执行多条redis命令，这些命令会被提交到服务器一次性执行完成，减小了网络开销

Lua脚本执行时不会有其他脚本或Redis命令执行，保证了操作不会被其他指令干扰

但是Lua脚本不会执行出错后的redis语句，且前面执行成功的redis语句也不会被回滚，所以还是不能完全解决原子性的问题

### （2）不支持持久性

前面说了Redis有三种持久化方式

- 快照（RDB）
- 只追加文件（AOF），三种fsync策略
  - always：可以基本满足持久化但是太耗性能
  - no和everysec：存在数据丢失情况
- RDB与AOF混合

所以redis不支持事务的持久性

# 二、性能优化

## 1.减少网络传输

使用批量操作减少网络传输

一个Redis命令执行：

1. 发送命令
2. 命令排队
3. 执行命令
4. 返回结果

第一步到第四步的执行时间称为一次RTT（往返时间），也就是数据在网络上传输的时间

使用批量操作可以减少网络传输次数，进而有效减少网络开销，大幅减少RTT（同时还能减少socket I/O成本）

### （1）原生批操作命令

- MGET、MSET
- HMGET、HMSET
- SADD

### （2）pipeline

对于不支持批量操作的命令，我们利用pipeline（流水线）将一批redis命令封装成一组，一次性提交到服务器（只需要一次网络传输）

- 原生批量操作命令是原子操作，pipeline 是非原子操作。
- pipeline 可以打包不同的命令，原生批量操作命令不可以。
- 原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。

## 2.大量key集中过期问题

对于过期的key采用定期删除+惰性删除策略

因为这个定期任务线程是在redis主线程中执行的，如果突然遇到大量过期的key会导致客户端请求没办法被及时处理，响应速度比较慢

### 解决

- 给key设置随机过期时间
- 开启lazy-free（惰性删除/延迟释放），让redis采用异步方式延迟释放key使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程

## 3.bigkey（大key）

什么是bigkey，简单来说就是value值比较大，占用内存比较多（像String类型的value超过10kb，符合类型的value包含元素超过5000个）

### 危害

会消耗更多的内存空间和带宽，还会对性能造成比较大的影响，所以应该尽量避免redis中存在bigkey

# 三、生产问题

## 1.缓存穿透

## 2.缓存击穿

## 3.缓存雪崩

## 4.保证缓存和数据库数据一致的问题

# 四、阻塞原因